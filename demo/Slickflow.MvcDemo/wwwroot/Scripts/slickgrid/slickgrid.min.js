if (function (e) { function t() { var e = !1, t = !1; this.stopPropagation = function () { e = !0 }, this.isPropagationStopped = function () { return e }, this.stopImmediatePropagation = function () { t = !0 }, this.isImmediatePropagationStopped = function () { return t } } function o() { var e = []; this.subscribe = function (t) { e.push(t) }, this.unsubscribe = function (t) { for (var o = e.length - 1; o >= 0; o--) e[o] === t && e.splice(o, 1) }, this.notify = function (o, n, l) { n = n || new t, l = l || this; for (var i, r = 0; r < e.length && !n.isPropagationStopped() && !n.isImmediatePropagationStopped() ; r++) i = e[r].call(l, n, o); return i } } function n() { var e = []; this.subscribe = function (t, o) { return e.push({ event: t, handler: o }), t.subscribe(o), this }, this.unsubscribe = function (t, o) { for (var n = e.length; n--;) if (e[n].event === t && e[n].handler === o) return e.splice(n, 1), void t.unsubscribe(o); return this }, this.unsubscribeAll = function () { for (var t = e.length; t--;) e[t].event.unsubscribe(e[t].handler); return e = [], this } } function l(e, t, o, n) { void 0 === o && void 0 === n && (o = e, n = t), this.fromRow = Math.min(e, o), this.fromCell = Math.min(t, n), this.toRow = Math.max(e, o), this.toCell = Math.max(t, n), this.isSingleRow = function () { return this.fromRow == this.toRow }, this.isSingleCell = function () { return this.fromRow == this.toRow && this.fromCell == this.toCell }, this.contains = function (e, t) { return e >= this.fromRow && e <= this.toRow && t >= this.fromCell && t <= this.toCell }, this.toString = function () { return this.isSingleCell() ? "(" + this.fromRow + ":" + this.fromCell + ")" : "(" + this.fromRow + ":" + this.fromCell + " - " + this.toRow + ":" + this.toCell + ")" } } function i() { this.__nonDataRow = !0 } function r() { this.__group = !0, this.__updated = !1, this.count = 0, this.value = null, this.title = null, this.collapsed = !1, this.totals = null } function a() { this.__groupTotals = !0, this.group = null } function s() { var e = null; this.isActive = function (t) { return t ? e === t : null !== e }, this.activate = function (t) { if (t !== e) { if (null !== e) throw "SlickGrid.EditorLock.activate: an editController is still active, can't activate another editController"; if (!t.commitCurrentEdit) throw "SlickGrid.EditorLock.activate: editController must implement .commitCurrentEdit()"; if (!t.cancelCurrentEdit) throw "SlickGrid.EditorLock.activate: editController must implement .cancelCurrentEdit()"; e = t } }, this.deactivate = function (t) { if (e !== t) throw "SlickGrid.EditorLock.deactivate: specified editController is not the currently active one"; e = null }, this.commitCurrentEdit = function () { return e ? e.commitCurrentEdit() : !0 }, this.cancelCurrentEdit = function () { return e ? e.cancelCurrentEdit() : !0 } } e.extend(!0, window, { Slick: { Event: o, EventData: t, EventHandler: n, Range: l, NonDataRow: i, Group: r, GroupTotals: a, EditorLock: s, GlobalEditorLock: new s } }), r.prototype = new i, r.prototype.equals = function (e) { return this.value === e.value && this.count === e.count && this.collapsed === e.collapsed }, a.prototype = new i }(jQuery), "undefined" == typeof jQuery) throw "SlickGrid requires jquery module to be loaded"; if (!jQuery.fn.drag) throw "SlickGrid requires jquery.event.drag module to be loaded"; if ("undefined" == typeof Slick) throw "slick.core.js not loaded"; !function ($) {
    function SlickGrid(container, data, columns, options) {
        function init() { if ($container = $(container), $container.length < 1) throw new Error("SlickGrid requires a valid container, " + container + " does not exist in the DOM."); maxSupportedCssHeight = maxSupportedCssHeight || getMaxSupportedCssHeight(), scrollbarDimensions = scrollbarDimensions || measureScrollbar(), options = $.extend({}, defaults, options), validateAndEnforceOptions(), columnDefaults.width = options.defaultColumnWidth, columnsById = {}; for (var e = 0; e < columns.length; e++) { var t = columns[e] = $.extend({}, columnDefaults, columns[e]); columnsById[t.id] = e, t.minWidth && t.width < t.minWidth && (t.width = t.minWidth), t.maxWidth && t.width > t.maxWidth && (t.width = t.maxWidth) } if (options.enableColumnReorder && !$.fn.sortable) throw new Error("SlickGrid's 'enableColumnReorder = true' option requires jquery-ui.sortable module to be loaded"); editController = { commitCurrentEdit: commitCurrentEdit, cancelCurrentEdit: cancelCurrentEdit }, $container.empty().css("overflow", "hidden").css("outline", 0).addClass(uid).addClass("ui-widget"), /relative|absolute|fixed/.test($container.css("position")) || $container.css("position", "relative"), $focusSink = $("<div tabIndex='0' hideFocus style='position:fixed;width:0;height:0;top:0;left:0;outline:0;'></div>").appendTo($container), $headerScroller = $("<div class='slick-header ui-state-default' style='overflow:hidden;position:relative;' />").appendTo($container), $headers = $("<div class='slick-header-columns' style='left:-1000px' />").appendTo($headerScroller), $headers.width(getHeadersWidth()), $headerRowScroller = $("<div class='slick-headerrow ui-state-default' style='overflow:hidden;position:relative;' />").appendTo($container), $headerRow = $("<div class='slick-headerrow-columns' />").appendTo($headerRowScroller), $headerRowSpacer = $("<div style='display:block;height:1px;position:absolute;top:0;left:0;'></div>").css("width", getCanvasWidth() + scrollbarDimensions.width + "px").appendTo($headerRowScroller), $topPanelScroller = $("<div class='slick-top-panel-scroller ui-state-default' style='overflow:hidden;position:relative;' />").appendTo($container), $topPanel = $("<div class='slick-top-panel' style='width:10000px' />").appendTo($topPanelScroller), options.showTopPanel || $topPanelScroller.hide(), options.showHeaderRow || $headerRowScroller.hide(), $viewport = $("<div class='slick-viewport' style='width:100%;overflow:auto;outline:0;position:relative;;'>").appendTo($container), $viewport.css("overflow-y", options.autoHeight ? "hidden" : "auto"), $canvas = $("<div class='grid-canvas' />").appendTo($viewport), $focusSink2 = $focusSink.clone().appendTo($container), options.explicitInitialization || finishInitialization() } function finishInitialization() { initialized || (initialized = !0, viewportW = parseFloat($.css($container[0], "width", !0)), measureCellPaddingAndBorder(), disableSelection($headers), options.enableTextSelectionOnCells || $viewport.bind("selectstart.ui", function (e) { return $(e.target).is("input,textarea") }), updateColumnCaches(), createColumnHeaders(), setupColumnSort(), createCssRules(), resizeCanvas(), bindAncestorScrollEvents(), $container.bind("resize.slickgrid", resizeCanvas), $viewport.bind("scroll", handleScroll), $headerScroller.bind("contextmenu", handleHeaderContextMenu).bind("click", handleHeaderClick).delegate(".slick-header-column", "mouseenter", handleHeaderMouseEnter).delegate(".slick-header-column", "mouseleave", handleHeaderMouseLeave), $headerRowScroller.bind("scroll", handleHeaderRowScroll), $focusSink.add($focusSink2).bind("keydown", handleKeyDown), $canvas.bind("keydown", handleKeyDown).bind("click", handleClick).bind("dblclick", handleDblClick).bind("contextmenu", handleContextMenu).bind("draginit", handleDragInit).bind("dragstart", { distance: 3 }, handleDragStart).bind("drag", handleDrag).bind("dragend", handleDragEnd).delegate(".slick-cell", "mouseenter", handleMouseEnter).delegate(".slick-cell", "mouseleave", handleMouseLeave), navigator.userAgent.toLowerCase().match(/webkit/) && navigator.userAgent.toLowerCase().match(/macintosh/) && $canvas.bind("mousewheel", handleMouseWheel)) } function registerPlugin(e) { plugins.unshift(e), e.init(self) } function unregisterPlugin(e) { for (var t = plugins.length; t >= 0; t--) if (plugins[t] === e) { plugins[t].destroy && plugins[t].destroy(), plugins.splice(t, 1); break } } function setSelectionModel(e) { selectionModel && (selectionModel.onSelectedRangesChanged.unsubscribe(handleSelectedRangesChanged), selectionModel.destroy && selectionModel.destroy()), selectionModel = e, selectionModel && (selectionModel.init(self), selectionModel.onSelectedRangesChanged.subscribe(handleSelectedRangesChanged)) } function getSelectionModel() { return selectionModel } function getCanvasNode() { return $canvas[0] } function measureScrollbar() { var e = $("<div style='position:absolute; top:-10000px; left:-10000px; width:100px; height:100px; overflow:scroll;'></div>").appendTo("body"), t = { width: e.width() - e[0].clientWidth, height: e.height() - e[0].clientHeight }; return e.remove(), t } function getHeadersWidth() { for (var e = 0, t = 0, o = columns.length; o > t; t++) { var n = columns[t].width; e += n } return e += scrollbarDimensions.width, Math.max(e, viewportW) + 1e3 } function getCanvasWidth() { for (var e = viewportHasVScroll ? viewportW - scrollbarDimensions.width : viewportW, t = 0, o = columns.length; o--;) t += columns[o].width; return options.fullWidthRows ? Math.max(t, e) : t } function updateCanvasWidth(e) { var t = canvasWidth; canvasWidth = getCanvasWidth(), canvasWidth != t && ($canvas.width(canvasWidth), $headerRow.width(canvasWidth), $headers.width(getHeadersWidth()), viewportHasHScroll = canvasWidth > viewportW - scrollbarDimensions.width), $headerRowSpacer.width(canvasWidth + (viewportHasVScroll ? scrollbarDimensions.width : 0)), (canvasWidth != t || e) && applyColumnWidths() } function disableSelection(e) { e && e.jquery && e.attr("unselectable", "on").css("MozUserSelect", "none").bind("selectstart.ui", function () { return !1 }) } function getMaxSupportedCssHeight() { for (var e = 1e6, t = navigator.userAgent.toLowerCase().match(/firefox/) ? 6e6 : 1e9, o = $("<div style='display:none' />").appendTo(document.body) ; ;) { var n = 2 * e; if (o.css("height", n), n > t || o.height() !== n) break; e = n } return o.remove(), e } function bindAncestorScrollEvents() { for (var e = $canvas[0]; (e = e.parentNode) != document.body && null != e;) if (e == $viewport[0] || e.scrollWidth != e.clientWidth || e.scrollHeight != e.clientHeight) { var t = $(e); $boundAncestors = $boundAncestors ? $boundAncestors.add(t) : t, t.bind("scroll." + uid, handleActiveCellPositionChange) } } function unbindAncestorScrollEvents() { $boundAncestors && ($boundAncestors.unbind("scroll." + uid), $boundAncestors = null) } function updateColumnHeader(e, t, o) { if (initialized) { var n = getColumnIndex(e); if (null != n) { var l = columns[n], i = $headers.children().eq(n); i && (void 0 !== t && (columns[n].name = t), void 0 !== o && (columns[n].toolTip = o), trigger(self.onBeforeHeaderCellDestroy, { node: i[0], column: l }), i.attr("title", o || "").children().eq(0).html(t), trigger(self.onHeaderCellRendered, { node: i[0], column: l })) } } } function getHeaderRow() { return $headerRow[0] } function getHeaderRowColumn(e) { var t = getColumnIndex(e), o = $headerRow.children().eq(t); return o && o[0] } function createColumnHeaders() { function e() { $(this).addClass("ui-state-hover") } function t() { $(this).removeClass("ui-state-hover") } $headers.find(".slick-header-column").each(function () { var e = $(this).data("column"); e && trigger(self.onBeforeHeaderCellDestroy, { node: this, column: e }) }), $headers.empty(), $headers.width(getHeadersWidth()), $headerRow.find(".slick-headerrow-column").each(function () { var e = $(this).data("column"); e && trigger(self.onBeforeHeaderRowCellDestroy, { node: this, column: e }) }), $headerRow.empty(); for (var o = 0; o < columns.length; o++) { var n = columns[o], l = $("<div class='ui-state-default slick-header-column' />").html("<span class='slick-column-name'>" + n.name + "</span>").width(n.width - headerColumnWidthDiff).attr("id", "" + uid + n.id).attr("title", n.toolTip || "").data("column", n).addClass(n.headerCssClass || "").appendTo($headers); if ((options.enableColumnReorder || n.sortable) && l.on("mouseenter", e).on("mouseleave", t), n.sortable && (l.addClass("slick-header-sortable"), l.append("<span class='slick-sort-indicator' />")), trigger(self.onHeaderCellRendered, { node: l[0], column: n }), options.showHeaderRow) { var i = $("<div class='ui-state-default slick-headerrow-column l" + o + " r" + o + "'></div>").data("column", n).appendTo($headerRow); trigger(self.onHeaderRowCellRendered, { node: i[0], column: n }) } } setSortColumns(sortColumns), setupColumnResize(), options.enableColumnReorder && setupColumnReorder() } function setupColumnSort() { $headers.click(function (e) { if (e.metaKey = e.metaKey || e.ctrlKey, !$(e.target).hasClass("slick-resizable-handle")) { var t = $(e.target).closest(".slick-header-column"); if (t.length) { var o = t.data("column"); if (o.sortable) { if (!getEditorLock().commitCurrentEdit()) return; for (var n = null, l = 0; l < sortColumns.length; l++) if (sortColumns[l].columnId == o.id) { n = sortColumns[l], n.sortAsc = !n.sortAsc; break } e.metaKey && options.multiColumnSort ? n && sortColumns.splice(l, 1) : ((e.shiftKey || e.metaKey) && options.multiColumnSort || (sortColumns = []), n ? 0 == sortColumns.length && sortColumns.push(n) : (n = { columnId: o.id, sortAsc: o.defaultSortAsc }, sortColumns.push(n))), setSortColumns(sortColumns), options.multiColumnSort ? trigger(self.onSort, { multiColumnSort: !0, sortCols: $.map(sortColumns, function (e) { return { sortCol: columns[getColumnIndex(e.columnId)], sortAsc: e.sortAsc } }) }, e) : trigger(self.onSort, { multiColumnSort: !1, sortCol: o, sortAsc: n.sortAsc }, e) } } } }) } function setupColumnReorder() { $headers.filter(":ui-sortable").sortable("destroy"), $headers.sortable({ containment: "parent", distance: 3, axis: "x", cursor: "default", tolerance: "intersection", helper: "clone", placeholder: "slick-sortable-placeholder ui-state-default slick-header-column", start: function (e, t) { t.placeholder.width(t.helper.outerWidth() - headerColumnWidthDiff), $(t.helper).addClass("slick-header-column-active") }, beforeStop: function (e, t) { $(t.helper).removeClass("slick-header-column-active") }, stop: function (e) { if (!getEditorLock().commitCurrentEdit()) return void $(this).sortable("cancel"); for (var t = $headers.sortable("toArray"), o = [], n = 0; n < t.length; n++) o.push(columns[getColumnIndex(t[n].replace(uid, ""))]); setColumns(o), trigger(self.onColumnsReordered, {}), e.stopPropagation(), setupColumnResize() } }) } function setupColumnResize() { var e, t, o, n, l, i, r, a, s; l = $headers.children(), l.find(".slick-resizable-handle").remove(), l.each(function (e, t) { columns[e].resizable && (void 0 === a && (a = e), s = e) }), void 0 !== a && l.each(function (c, d) { a > c || options.forceFitColumns && c >= s || (e = $(d), $("<div class='slick-resizable-handle' />").appendTo(d).bind("dragstart", function (e, a) { if (!getEditorLock().commitCurrentEdit()) return !1; n = e.pageX, $(this).parent().addClass("slick-header-column-active"); var s = null, d = null; if (l.each(function (e, t) { columns[e].previousWidth = $(t).outerWidth() }), options.forceFitColumns) for (s = 0, d = 0, t = c + 1; t < l.length; t++) o = columns[t], o.resizable && (null !== d && (o.maxWidth ? d += o.maxWidth - o.previousWidth : d = null), s += o.previousWidth - Math.max(o.minWidth || 0, absoluteColumnMinWidth)); var u = 0, h = 0; for (t = 0; c >= t; t++) o = columns[t], o.resizable && (null !== h && (o.maxWidth ? h += o.maxWidth - o.previousWidth : h = null), u += o.previousWidth - Math.max(o.minWidth || 0, absoluteColumnMinWidth)); null === s && (s = 1e5), null === u && (u = 1e5), null === d && (d = 1e5), null === h && (h = 1e5), r = n + Math.min(s, h), i = n - Math.min(u, d) }).bind("drag", function (e, a) { var s, d, u = Math.min(r, Math.max(i, e.pageX)) - n; if (0 > u) { for (d = u, t = c; t >= 0; t--) o = columns[t], o.resizable && (s = Math.max(o.minWidth || 0, absoluteColumnMinWidth), d && o.previousWidth + d < s ? (d += o.previousWidth - s, o.width = s) : (o.width = o.previousWidth + d, d = 0)); if (options.forceFitColumns) for (d = -u, t = c + 1; t < l.length; t++) o = columns[t], o.resizable && (d && o.maxWidth && o.maxWidth - o.previousWidth < d ? (d -= o.maxWidth - o.previousWidth, o.width = o.maxWidth) : (o.width = o.previousWidth + d, d = 0)) } else { for (d = u, t = c; t >= 0; t--) o = columns[t], o.resizable && (d && o.maxWidth && o.maxWidth - o.previousWidth < d ? (d -= o.maxWidth - o.previousWidth, o.width = o.maxWidth) : (o.width = o.previousWidth + d, d = 0)); if (options.forceFitColumns) for (d = -u, t = c + 1; t < l.length; t++) o = columns[t], o.resizable && (s = Math.max(o.minWidth || 0, absoluteColumnMinWidth), d && o.previousWidth + d < s ? (d += o.previousWidth - s, o.width = s) : (o.width = o.previousWidth + d, d = 0)) } applyColumnHeaderWidths(), options.syncColumnCellResize && applyColumnWidths() }).bind("dragend", function (e, n) { var i; for ($(this).parent().removeClass("slick-header-column-active"), t = 0; t < l.length; t++) o = columns[t], i = $(l[t]).outerWidth(), o.previousWidth !== i && o.rerenderOnResize && invalidateAllRows(); updateCanvasWidth(!0), render(), trigger(self.onColumnsResized, {}) })) }) } function getVBoxDelta(e) { var t = ["borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom"], o = 0; return $.each(t, function (t, n) { o += parseFloat(e.css(n)) || 0 }), o } function measureCellPaddingAndBorder() { var e, t = ["borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight"], o = ["borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom"]; e = $("<div class='ui-state-default slick-header-column' style='visibility:hidden'>-</div>").appendTo($headers), headerColumnWidthDiff = headerColumnHeightDiff = 0, "border-box" != e.css("box-sizing") && "border-box" != e.css("-moz-box-sizing") && "border-box" != e.css("-webkit-box-sizing") && ($.each(t, function (t, o) { headerColumnWidthDiff += parseFloat(e.css(o)) || 0 }), $.each(o, function (t, o) { headerColumnHeightDiff += parseFloat(e.css(o)) || 0 })), e.remove(); var n = $("<div class='slick-row' />").appendTo($canvas); e = $("<div class='slick-cell' id='' style='visibility:hidden'>-</div>").appendTo(n), cellWidthDiff = cellHeightDiff = 0, "border-box" != e.css("box-sizing") && "border-box" != e.css("-moz-box-sizing") && "border-box" != e.css("-webkit-box-sizing") && ($.each(t, function (t, o) { cellWidthDiff += parseFloat(e.css(o)) || 0 }), $.each(o, function (t, o) { cellHeightDiff += parseFloat(e.css(o)) || 0 })), n.remove(), absoluteColumnMinWidth = Math.max(headerColumnWidthDiff, cellWidthDiff) } function createCssRules() { $style = $("<style type='text/css' rel='stylesheet' />").appendTo($("head")); for (var e = options.rowHeight - cellHeightDiff, t = ["." + uid + " .slick-header-column { left: 1000px; }", "." + uid + " .slick-top-panel { height:" + options.topPanelHeight + "px; }", "." + uid + " .slick-headerrow-columns { height:" + options.headerRowHeight + "px; }", "." + uid + " .slick-cell { height:" + e + "px; }", "." + uid + " .slick-row { height:" + options.rowHeight + "px; }"], o = 0; o < columns.length; o++) t.push("." + uid + " .l" + o + " { }"), t.push("." + uid + " .r" + o + " { }"); $style[0].styleSheet ? $style[0].styleSheet.cssText = t.join(" ") : $style[0].appendChild(document.createTextNode(t.join(" "))) } function getColumnCssRules(e) { if (!stylesheet) { for (var t = document.styleSheets, o = 0; o < t.length; o++) if ((t[o].ownerNode || t[o].owningElement) == $style[0]) { stylesheet = t[o]; break } if (!stylesheet) throw new Error("Cannot find stylesheet."); columnCssRulesL = [], columnCssRulesR = []; for (var n, l, i = stylesheet.cssRules || stylesheet.rules, o = 0; o < i.length; o++) { var r = i[o].selectorText; (n = /\.l\d+/.exec(r)) ? (l = parseInt(n[0].substr(2, n[0].length - 2), 10), columnCssRulesL[l] = i[o]) : (n = /\.r\d+/.exec(r)) && (l = parseInt(n[0].substr(2, n[0].length - 2), 10), columnCssRulesR[l] = i[o]) } } return { left: columnCssRulesL[e], right: columnCssRulesR[e] } } function removeCssRules() { $style.remove(), stylesheet = null } function destroy() { getEditorLock().cancelCurrentEdit(), trigger(self.onBeforeDestroy, {}); for (var e = plugins.length; e--;) unregisterPlugin(plugins[e]); options.enableColumnReorder && $headers.filter(":ui-sortable").sortable("destroy"), unbindAncestorScrollEvents(), $container.unbind(".slickgrid"), removeCssRules(), $canvas.unbind("draginit dragstart dragend drag"), $container.empty().removeClass(uid) } function trigger(e, t, o) { return o = o || new Slick.EventData, t = t || {}, t.grid = self, e.notify(t, o, self) } function getEditorLock() { return options.editorLock } function getEditController() { return editController } function getColumnIndex(e) { return columnsById[e] } function autosizeColumns() { var e, t, o, n = [], l = 0, i = 0, r = viewportHasVScroll ? viewportW - scrollbarDimensions.width : viewportW; for (e = 0; e < columns.length; e++) t = columns[e], n.push(t.width), i += t.width, t.resizable && (l += t.width - Math.max(t.minWidth, absoluteColumnMinWidth)); for (o = i; i > r && l;) { var a = (i - r) / l; for (e = 0; e < columns.length && i > r; e++) { t = columns[e]; var s = n[e]; if (!(!t.resizable || s <= t.minWidth || absoluteColumnMinWidth >= s)) { var c = Math.max(t.minWidth, absoluteColumnMinWidth), d = Math.floor(a * (s - c)) || 1; d = Math.min(d, s - c), i -= d, l -= d, n[e] -= d } } if (i >= o) break; o = i } for (o = i; r > i;) { var u = r / i; for (e = 0; e < columns.length && r > i; e++) { t = columns[e]; var h, g = n[e]; h = !t.resizable || t.maxWidth <= g ? 0 : Math.min(Math.floor(u * g) - g, t.maxWidth - g || 1e6) || 1, i += h, n[e] += h } if (o >= i) break; o = i } var f = !1; for (e = 0; e < columns.length; e++) columns[e].rerenderOnResize && columns[e].width != n[e] && (f = !0), columns[e].width = n[e]; applyColumnHeaderWidths(), updateCanvasWidth(!0), f && (invalidateAllRows(), render()) } function applyColumnHeaderWidths() { if (initialized) { for (var e, t = 0, o = $headers.children(), n = o.length; n > t; t++) e = $(o[t]), e.width() !== columns[t].width - headerColumnWidthDiff && e.width(columns[t].width - headerColumnWidthDiff); updateColumnCaches() } } function applyColumnWidths() { for (var e, t, o = 0, n = 0; n < columns.length; n++) e = columns[n].width, t = getColumnCssRules(n), t.left.style.left = o + "px", t.right.style.right = canvasWidth - o - e + "px", o += columns[n].width } function setSortColumn(e, t) { setSortColumns([{ columnId: e, sortAsc: t }]) } function setSortColumns(e) { sortColumns = e; var t = $headers.children(); t.removeClass("slick-header-column-sorted").find(".slick-sort-indicator").removeClass("slick-sort-indicator-asc slick-sort-indicator-desc"), $.each(sortColumns, function (e, o) { null == o.sortAsc && (o.sortAsc = !0); var n = getColumnIndex(o.columnId); null != n && t.eq(n).addClass("slick-header-column-sorted").find(".slick-sort-indicator").addClass(o.sortAsc ? "slick-sort-indicator-asc" : "slick-sort-indicator-desc") }) } function getSortColumns() { return sortColumns } function handleSelectedRangesChanged(e, t) { selectedRows = []; for (var o = {}, n = 0; n < t.length; n++) for (var l = t[n].fromRow; l <= t[n].toRow; l++) { o[l] || (selectedRows.push(l), o[l] = {}); for (var i = t[n].fromCell; i <= t[n].toCell; i++) canCellBeSelected(l, i) && (o[l][columns[i].id] = options.selectedCellCssClass) } setCellCssStyles(options.selectedCellCssClass, o), trigger(self.onSelectedRowsChanged, { rows: getSelectedRows() }, e) } function getColumns() { return columns } function updateColumnCaches() { columnPosLeft = [], columnPosRight = []; for (var e = 0, t = 0, o = columns.length; o > t; t++) columnPosLeft[t] = e, columnPosRight[t] = e + columns[t].width, e += columns[t].width } function setColumns(e) { columns = e, columnsById = {}; for (var t = 0; t < columns.length; t++) { var o = columns[t] = $.extend({}, columnDefaults, columns[t]); columnsById[o.id] = t, o.minWidth && o.width < o.minWidth && (o.width = o.minWidth), o.maxWidth && o.width > o.maxWidth && (o.width = o.maxWidth) } updateColumnCaches(), initialized && (invalidateAllRows(), createColumnHeaders(), removeCssRules(), createCssRules(), resizeCanvas(), applyColumnWidths(), handleScroll()) } function getOptions() { return options } function setOptions(e) { getEditorLock().commitCurrentEdit() && (makeActiveCellNormal(), options.enableAddRow !== e.enableAddRow && invalidateRow(getDataLength()), options = $.extend(options, e), validateAndEnforceOptions(), $viewport.css("overflow-y", options.autoHeight ? "hidden" : "auto"), render()) } function validateAndEnforceOptions() { options.autoHeight && (options.leaveSpaceForNewRows = !1) } function setData(e, t) { data = e, invalidateAllRows(), updateRowCount(), t && scrollTo(0) } function getData() { return data } function getDataLength() { return data.getLength ? data.getLength() : data.length } function getDataLengthIncludingAddNew() { return getDataLength() + (options.enableAddRow ? 1 : 0) } function getDataItem(e) { return data.getItem ? data.getItem(e) : data[e] } function getTopPanel() { return $topPanel[0] } function setTopPanelVisibility(e) { options.showTopPanel != e && (options.showTopPanel = e, e ? $topPanelScroller.slideDown("fast", resizeCanvas) : $topPanelScroller.slideUp("fast", resizeCanvas)) } function setHeaderRowVisibility(e) { options.showHeaderRow != e && (options.showHeaderRow = e, e ? $headerRowScroller.slideDown("fast", resizeCanvas) : $headerRowScroller.slideUp("fast", resizeCanvas)) } function getContainerNode() { return $container.get(0) } function getRowTop(e) { return options.rowHeight * e - offset } function getRowFromPosition(e) { return Math.floor((e + offset) / options.rowHeight) } function scrollTo(e) { e = Math.max(e, 0), e = Math.min(e, th - viewportH + (viewportHasHScroll ? scrollbarDimensions.height : 0)); var t = offset; page = Math.min(n - 1, Math.floor(e / ph)), offset = Math.round(page * cj); var o = e - offset; if (offset != t) { var l = getVisibleRange(o); cleanupRows(l), updateRowPositions() } prevScrollTop != o && (vScrollDir = o + offset > prevScrollTop + t ? 1 : -1, $viewport[0].scrollTop = lastRenderedScrollTop = scrollTop = prevScrollTop = o, trigger(self.onViewportChanged, {})) } function defaultFormatter(e, t, o, n, l) { return null == o ? "" : (o + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;") } function getFormatter(e, t) { var o = data.getItemMetadata && data.getItemMetadata(e), n = o && o.columns && (o.columns[t.id] || o.columns[getColumnIndex(t.id)]); return n && n.formatter || o && o.formatter || t.formatter || options.formatterFactory && options.formatterFactory.getFormatter(t) || options.defaultFormatter } function getEditor(e, t) { var o = columns[t], n = data.getItemMetadata && data.getItemMetadata(e), l = n && n.columns; return l && l[o.id] && void 0 !== l[o.id].editor ? l[o.id].editor : l && l[t] && void 0 !== l[t].editor ? l[t].editor : o.editor || options.editorFactory && options.editorFactory.getEditor(o) } function getDataItemValueForColumn(e, t) { return options.dataItemColumnValueExtractor ? options.dataItemColumnValueExtractor(e, t) : e[t.field] } function appendRowHtml(e, t, o, n) { var l = getDataItem(t), i = n > t && !l, r = "slick-row" + (i ? " loading" : "") + (t === activeRow ? " active" : "") + (t % 2 == 1 ? " odd" : " even"); l || (r += " " + options.addNewRowCssClass); var a = data.getItemMetadata && data.getItemMetadata(t); a && a.cssClasses && (r += " " + a.cssClasses), e.push("<div class='ui-widget-content " + r + "' style='top:" + getRowTop(t) + "px'>"); for (var s, c, d = 0, u = columns.length; u > d; d++) { if (c = columns[d], s = 1, a && a.columns) { var h = a.columns[c.id] || a.columns[d]; s = h && h.colspan || 1, "*" === s && (s = u - d) } if (columnPosRight[Math.min(u - 1, d + s - 1)] > o.leftPx) { if (columnPosLeft[d] > o.rightPx) break; appendCellHtml(e, t, d, s, l) } s > 1 && (d += s - 1) } e.push("</div>") } function appendCellHtml(e, t, o, n, l) { var i = columns[o], r = "slick-cell l" + o + " r" + Math.min(columns.length - 1, o + n - 1) + (i.cssClass ? " " + i.cssClass : ""); t === activeRow && o === activeCell && (r += " active"); for (var a in cellCssClasses) cellCssClasses[a][t] && cellCssClasses[a][t][i.id] && (r += " " + cellCssClasses[a][t][i.id]); if (e.push("<div class='" + r + "'>"), l) { var s = getDataItemValueForColumn(l, i); e.push(getFormatter(t, i)(t, o, s, i, l)) } e.push("</div>"), rowsCache[t].cellRenderQueue.push(o), rowsCache[t].cellColSpans[o] = n } function cleanupRows(e) { for (var t in rowsCache) (t = parseInt(t, 10)) !== activeRow && (t < e.top || t > e.bottom) && removeRowFromCache(t) } function invalidate() { updateRowCount(), invalidateAllRows(), render() } function invalidateAllRows() { currentEditor && makeActiveCellNormal(); for (var e in rowsCache) removeRowFromCache(e) } function removeRowFromCache(e) { var t = rowsCache[e]; t && (rowNodeFromLastMouseWheelEvent == t.rowNode ? (t.rowNode.style.display = "none", zombieRowNodeFromLastMouseWheelEvent = rowNodeFromLastMouseWheelEvent) : $canvas[0].removeChild(t.rowNode), delete rowsCache[e], delete postProcessedRows[e], renderedRows--, counter_rows_removed++) } function invalidateRows(e) { var t, o; if (e && e.length) for (vScrollDir = 0, t = 0, o = e.length; o > t; t++) currentEditor && activeRow === e[t] && makeActiveCellNormal(), rowsCache[e[t]] && removeRowFromCache(e[t]) } function invalidateRow(e) { invalidateRows([e]) } function updateCell(e, t) { var o = getCellNode(e, t); if (o) { var n = columns[t], l = getDataItem(e); currentEditor && activeRow === e && activeCell === t ? currentEditor.loadValue(l) : (o.innerHTML = l ? getFormatter(e, n)(e, t, getDataItemValueForColumn(l, n), n, l) : "", invalidatePostProcessingResults(e)) } } function updateRow(e) { var t = rowsCache[e]; if (t) { ensureCellNodesInRowsCache(e); var o = getDataItem(e); for (var n in t.cellNodesByColumnIdx) if (t.cellNodesByColumnIdx.hasOwnProperty(n)) { n = 0 | n; var l = columns[n], i = t.cellNodesByColumnIdx[n]; e === activeRow && n === activeCell && currentEditor ? currentEditor.loadValue(o) : o ? i.innerHTML = getFormatter(e, l)(e, n, getDataItemValueForColumn(o, l), l, o) : i.innerHTML = "" } invalidatePostProcessingResults(e) } } function getViewportHeight() { return parseFloat($.css($container[0], "height", !0)) - parseFloat($.css($container[0], "paddingTop", !0)) - parseFloat($.css($container[0], "paddingBottom", !0)) - parseFloat($.css($headerScroller[0], "height")) - getVBoxDelta($headerScroller) - (options.showTopPanel ? options.topPanelHeight + getVBoxDelta($topPanelScroller) : 0) - (options.showHeaderRow ? options.headerRowHeight + getVBoxDelta($headerRowScroller) : 0) } function resizeCanvas() { initialized && (viewportH = options.autoHeight ? options.rowHeight * getDataLengthIncludingAddNew() : getViewportHeight(), numVisibleRows = Math.ceil(viewportH / options.rowHeight), viewportW = parseFloat($.css($container[0], "width", !0)), options.autoHeight || $viewport.height(viewportH), options.forceFitColumns && autosizeColumns(), updateRowCount(), handleScroll(), lastRenderedScrollLeft = -1, render()) } function updateRowCount() { if (initialized) { var e = getDataLengthIncludingAddNew(), t = e + (options.leaveSpaceForNewRows ? numVisibleRows - 1 : 0), o = viewportHasVScroll; viewportHasVScroll = !options.autoHeight && t * options.rowHeight > viewportH, makeActiveCellNormal(); var l = e - 1; for (var i in rowsCache) i >= l && removeRowFromCache(i); activeCellNode && activeRow > l && resetActiveCell(); var r = h; th = Math.max(options.rowHeight * t, viewportH - scrollbarDimensions.height), maxSupportedCssHeight > th ? (h = ph = th, n = 1, cj = 0) : (h = maxSupportedCssHeight, ph = h / 100, n = Math.floor(th / ph), cj = (th - h) / (n - 1)), h !== r && ($canvas.css("height", h), scrollTop = $viewport[0].scrollTop); var a = th - viewportH >= scrollTop + offset; 0 == th || 0 == scrollTop ? page = offset = 0 : scrollTo(a ? scrollTop + offset : th - viewportH), h != r && options.autoHeight && resizeCanvas(), options.forceFitColumns && o != viewportHasVScroll && autosizeColumns(), updateCanvasWidth(!1) } } function getVisibleRange(e, t) { return null == e && (e = scrollTop), null == t && (t = scrollLeft), { top: getRowFromPosition(e), bottom: getRowFromPosition(e + viewportH) + 1, leftPx: t, rightPx: t + viewportW } } function getRenderedRange(e, t) { var o = getVisibleRange(e, t), n = Math.round(viewportH / options.rowHeight), l = 3; return -1 == vScrollDir ? (o.top -= n, o.bottom += l) : 1 == vScrollDir ? (o.top -= l, o.bottom += n) : (o.top -= l, o.bottom += l), o.top = Math.max(0, o.top), o.bottom = Math.min(getDataLengthIncludingAddNew() - 1, o.bottom), o.leftPx -= viewportW, o.rightPx += viewportW, o.leftPx = Math.max(0, o.leftPx), o.rightPx = Math.min(canvasWidth, o.rightPx), o } function ensureCellNodesInRowsCache(e) { var t = rowsCache[e]; if (t && t.cellRenderQueue.length) for (var o = t.rowNode.lastChild; t.cellRenderQueue.length;) { var n = t.cellRenderQueue.pop(); t.cellNodesByColumnIdx[n] = o, o = o.previousSibling } } function cleanUpCells(e, t) { var o = 0, n = rowsCache[t], l = []; for (var i in n.cellNodesByColumnIdx) if (n.cellNodesByColumnIdx.hasOwnProperty(i)) { i = 0 | i; var r = n.cellColSpans[i]; (columnPosLeft[i] > e.rightPx || columnPosRight[Math.min(columns.length - 1, i + r - 1)] < e.leftPx) && (t != activeRow || i != activeCell) && l.push(i) } for (var a; null != (a = l.pop()) ;) n.rowNode.removeChild(n.cellNodesByColumnIdx[a]), delete n.cellColSpans[a], delete n.cellNodesByColumnIdx[a], postProcessedRows[t] && delete postProcessedRows[t][a], o++ } function cleanUpAndRenderCells(e) { for (var t, o, n, l = [], i = [], r = 0, a = e.top, s = e.bottom; s >= a; a++) if (t = rowsCache[a]) { ensureCellNodesInRowsCache(a), cleanUpCells(e, a), o = 0; var c = data.getItemMetadata && data.getItemMetadata(a); c = c && c.columns; for (var d = getDataItem(a), u = 0, h = columns.length; h > u && !(columnPosLeft[u] > e.rightPx) ; u++) if (null == (n = t.cellColSpans[u])) { if (n = 1, c) { var g = c[columns[u].id] || c[u]; n = g && g.colspan || 1, "*" === n && (n = h - u) } columnPosRight[Math.min(h - 1, u + n - 1)] > e.leftPx && (appendCellHtml(l, a, u, n, d), o++), u += n > 1 ? n - 1 : 0 } else u += n > 1 ? n - 1 : 0; o && (r += o, i.push(a)) } if (l.length) { var f = document.createElement("div"); f.innerHTML = l.join(""); for (var v, m; null != (v = i.pop()) ;) { t = rowsCache[v]; for (var p; null != (p = t.cellRenderQueue.pop()) ;) m = f.lastChild, t.rowNode.appendChild(m), t.cellNodesByColumnIdx[p] = m } } } function renderRows(e) { for (var t = $canvas[0], o = [], n = [], l = !1, i = getDataLength(), r = e.top, a = e.bottom; a >= r; r++) rowsCache[r] || (renderedRows++, n.push(r), rowsCache[r] = { rowNode: null, cellColSpans: [], cellNodesByColumnIdx: [], cellRenderQueue: [] }, appendRowHtml(o, r, e, i), activeCellNode && activeRow === r && (l = !0), counter_rows_rendered++); if (n.length) { var s = document.createElement("div"); s.innerHTML = o.join(""); for (var r = 0, a = n.length; a > r; r++) rowsCache[n[r]].rowNode = t.appendChild(s.firstChild); l && (activeCellNode = getCellNode(activeRow, activeCell)) } } function startPostProcessing() { options.enableAsyncPostRender && (clearTimeout(h_postrender), h_postrender = setTimeout(asyncPostProcessRows, options.asyncPostRenderDelay)) } function invalidatePostProcessingResults(e) { delete postProcessedRows[e], postProcessFromRow = Math.min(postProcessFromRow, e), postProcessToRow = Math.max(postProcessToRow, e), startPostProcessing() } function updateRowPositions() { for (var e in rowsCache) rowsCache[e].rowNode.style.top = getRowTop(e) + "px" } function render() {
            if (initialized) {
                var e = getVisibleRange(), t = getRenderedRange(); cleanupRows(t), lastRenderedScrollLeft != scrollLeft && cleanUpAndRenderCells(t), renderRows(t), postProcessFromRow = e.top, postProcessToRow = Math.min(getDataLengthIncludingAddNew() - 1, e.bottom), startPostProcessing(), lastRenderedScrollTop = scrollTop, lastRenderedScrollLeft = scrollLeft, h_render = null;
            }
        } function handleHeaderRowScroll() { var e = $headerRowScroller[0].scrollLeft; e != $viewport[0].scrollLeft && ($viewport[0].scrollLeft = e) } function handleScroll() { scrollTop = $viewport[0].scrollTop, scrollLeft = $viewport[0].scrollLeft; var e = Math.abs(scrollTop - prevScrollTop), t = Math.abs(scrollLeft - prevScrollLeft); if (t && (prevScrollLeft = scrollLeft, $headerScroller[0].scrollLeft = scrollLeft, $topPanelScroller[0].scrollLeft = scrollLeft, $headerRowScroller[0].scrollLeft = scrollLeft), e) if (vScrollDir = scrollTop > prevScrollTop ? 1 : -1, prevScrollTop = scrollTop, viewportH > e) scrollTo(scrollTop + offset); else { var o = offset; page = h == viewportH ? 0 : Math.min(n - 1, Math.floor(scrollTop * ((th - viewportH) / (h - viewportH)) * (1 / ph))), offset = Math.round(page * cj), o != offset && invalidateAllRows() } (t || e) && (h_render && clearTimeout(h_render), (Math.abs(lastRenderedScrollTop - scrollTop) > 20 || Math.abs(lastRenderedScrollLeft - scrollLeft) > 20) && (options.forceSyncScrolling || Math.abs(lastRenderedScrollTop - scrollTop) < viewportH && Math.abs(lastRenderedScrollLeft - scrollLeft) < viewportW ? render() : h_render = setTimeout(render, 50), trigger(self.onViewportChanged, {}))), trigger(self.onScroll, { scrollLeft: scrollLeft, scrollTop: scrollTop }) } function asyncPostProcessRows() { for (var e = getDataLength() ; postProcessToRow >= postProcessFromRow;) { var t = vScrollDir >= 0 ? postProcessFromRow++ : postProcessToRow--, o = rowsCache[t]; if (o && !(t >= e)) { postProcessedRows[t] || (postProcessedRows[t] = {}), ensureCellNodesInRowsCache(t); for (var n in o.cellNodesByColumnIdx) if (o.cellNodesByColumnIdx.hasOwnProperty(n)) { n = 0 | n; var l = columns[n]; if (l.asyncPostRender && !postProcessedRows[t][n]) { var i = o.cellNodesByColumnIdx[n]; i && l.asyncPostRender(i, t, getDataItem(t), l), postProcessedRows[t][n] = !0 } } return void (h_postrender = setTimeout(asyncPostProcessRows, options.asyncPostRenderDelay)) } } } function updateCellCssStylesOnRenderedRows(e, t) { var o, n, l, i; for (var r in rowsCache) { if (i = t && t[r], l = e && e[r], i) for (n in i) l && i[n] == l[n] || (o = getCellNode(r, getColumnIndex(n)), o && $(o).removeClass(i[n])); if (l) for (n in l) i && i[n] == l[n] || (o = getCellNode(r, getColumnIndex(n)), o && $(o).addClass(l[n])) } } function addCellCssStyles(e, t) { if (cellCssClasses[e]) throw "addCellCssStyles: cell CSS hash with key '" + e + "' already exists."; cellCssClasses[e] = t, updateCellCssStylesOnRenderedRows(t, null), trigger(self.onCellCssStylesChanged, { key: e, hash: t }) } function removeCellCssStyles(e) { cellCssClasses[e] && (updateCellCssStylesOnRenderedRows(null, cellCssClasses[e]), delete cellCssClasses[e], trigger(self.onCellCssStylesChanged, { key: e, hash: null })) } function setCellCssStyles(e, t) { var o = cellCssClasses[e]; cellCssClasses[e] = t, updateCellCssStylesOnRenderedRows(t, o), trigger(self.onCellCssStylesChanged, { key: e, hash: t }) } function getCellCssStyles(e) { return cellCssClasses[e] } function flashCell(e, t, o) { function n(e) { e && setTimeout(function () { l.queue(function () { l.toggleClass(options.cellFlashingCssClass).dequeue(), n(e - 1) }) }, o) } if (o = o || 100, rowsCache[e]) { var l = $(getCellNode(e, t)); n(4) } } function handleMouseWheel(e) { var t = $(e.target).closest(".slick-row")[0]; t != rowNodeFromLastMouseWheelEvent && (zombieRowNodeFromLastMouseWheelEvent && zombieRowNodeFromLastMouseWheelEvent != t && ($canvas[0].removeChild(zombieRowNodeFromLastMouseWheelEvent), zombieRowNodeFromLastMouseWheelEvent = null), rowNodeFromLastMouseWheelEvent = t) } function handleDragInit(e, t) { var o = getCellFromEvent(e); if (!o || !cellExists(o.row, o.cell)) return !1; var n = trigger(self.onDragInit, t, e); return e.isImmediatePropagationStopped() ? n : !1 } function handleDragStart(e, t) { var o = getCellFromEvent(e); if (!o || !cellExists(o.row, o.cell)) return !1; var n = trigger(self.onDragStart, t, e); return e.isImmediatePropagationStopped() ? n : !1 } function handleDrag(e, t) { return trigger(self.onDrag, t, e) } function handleDragEnd(e, t) { trigger(self.onDragEnd, t, e) } function handleKeyDown(e) { trigger(self.onKeyDown, { row: activeRow, cell: activeCell }, e); var t = e.isImmediatePropagationStopped(); if (!t) if (e.shiftKey || e.altKey || e.ctrlKey) 9 != e.which || !e.shiftKey || e.ctrlKey || e.altKey || (t = navigatePrev()); else if (27 == e.which) { if (!getEditorLock().isActive()) return; cancelEditAndSetFocus() } else 34 == e.which ? (navigatePageDown(), t = !0) : 33 == e.which ? (navigatePageUp(), t = !0) : 37 == e.which ? t = navigateLeft() : 39 == e.which ? t = navigateRight() : 38 == e.which ? t = navigateUp() : 40 == e.which ? t = navigateDown() : 9 == e.which ? t = navigateNext() : 13 == e.which && (options.editable && (currentEditor ? activeRow === getDataLength() ? navigateDown() : commitEditAndSetFocus() : getEditorLock().commitCurrentEdit() && makeActiveCellEditable()), t = !0); if (t) { e.stopPropagation(), e.preventDefault(); try { e.originalEvent.keyCode = 0 } catch (o) { } } } function handleClick(e) { currentEditor || (e.target != document.activeElement || $(e.target).hasClass("slick-cell")) && setFocus(); var t = getCellFromEvent(e); !t || null !== currentEditor && activeRow == t.row && activeCell == t.cell || (trigger(self.onClick, { row: t.row, cell: t.cell }, e), e.isImmediatePropagationStopped() || activeCell == t.cell && activeRow == t.row || !canCellBeActive(t.row, t.cell) || (!getEditorLock().isActive() || getEditorLock().commitCurrentEdit()) && (scrollRowIntoView(t.row, !1), setActiveCellInternal(getCellNode(t.row, t.cell)))) } function handleContextMenu(e) { var t = $(e.target).closest(".slick-cell", $canvas); 0 !== t.length && (activeCellNode !== t[0] || null === currentEditor) && trigger(self.onContextMenu, {}, e) } function handleDblClick(e) { var t = getCellFromEvent(e); !t || null !== currentEditor && activeRow == t.row && activeCell == t.cell || (trigger(self.onDblClick, { row: t.row, cell: t.cell }, e), e.isImmediatePropagationStopped() || options.editable && gotoCell(t.row, t.cell, !0)) } function handleHeaderMouseEnter(e) { trigger(self.onHeaderMouseEnter, { column: $(this).data("column") }, e) } function handleHeaderMouseLeave(e) { trigger(self.onHeaderMouseLeave, { column: $(this).data("column") }, e) } function handleHeaderContextMenu(e) { var t = $(e.target).closest(".slick-header-column", ".slick-header-columns"), o = t && t.data("column"); trigger(self.onHeaderContextMenu, { column: o }, e) } function handleHeaderClick(e) { var t = $(e.target).closest(".slick-header-column", ".slick-header-columns"), o = t && t.data("column"); o && trigger(self.onHeaderClick, { column: o }, e) } function handleMouseEnter(e) { trigger(self.onMouseEnter, {}, e) } function handleMouseLeave(e) { trigger(self.onMouseLeave, {}, e) } function cellExists(e, t) { return !(0 > e || e >= getDataLength() || 0 > t || t >= columns.length) } function getCellFromPoint(e, t) { for (var o = getRowFromPosition(t), n = 0, l = 0, i = 0; i < columns.length && e > l; i++) l += columns[i].width, n++; return 0 > n && (n = 0), { row: o, cell: n - 1 } } function getCellFromNode(e) { var t = /l\d+/.exec(e.className); if (!t) throw "getCellFromNode: cannot get cell - " + e.className; return parseInt(t[0].substr(1, t[0].length - 1), 10) } function getRowFromNode(e) { for (var t in rowsCache) if (rowsCache[t].rowNode === e) return 0 | t; return null } function getCellFromEvent(e) { var t = $(e.target).closest(".slick-cell", $canvas); if (!t.length) return null; var o = getRowFromNode(t[0].parentNode), n = getCellFromNode(t[0]); return null == o || null == n ? null : { row: o, cell: n } } function getCellNodeBox(e, t) { if (!cellExists(e, t)) return null; for (var o = getRowTop(e), n = o + options.rowHeight - 1, l = 0, i = 0; t > i; i++) l += columns[i].width; var r = l + columns[t].width; return { top: o, left: l, bottom: n, right: r } } function resetActiveCell() { setActiveCellInternal(null, !1) } function setFocus() { -1 == tabbingDirection ? $focusSink[0].focus() : $focusSink2[0].focus() } function scrollCellIntoView(e, t, o) { scrollRowIntoView(e, o); var n = getColspan(e, t), l = columnPosLeft[t], i = columnPosRight[t + (n > 1 ? n - 1 : 0)], r = scrollLeft + viewportW; scrollLeft > l ? ($viewport.scrollLeft(l), handleScroll(), render()) : i > r && ($viewport.scrollLeft(Math.min(l, i - $viewport[0].clientWidth)), handleScroll(), render()) } function setActiveCellInternal(e, t) { null !== activeCellNode && (makeActiveCellNormal(), $(activeCellNode).removeClass("active"), rowsCache[activeRow] && $(rowsCache[activeRow].rowNode).removeClass("active")); var o = activeCellNode !== e; activeCellNode = e, null != activeCellNode ? (activeRow = getRowFromNode(activeCellNode.parentNode), activeCell = activePosX = getCellFromNode(activeCellNode), null == t && (t = activeRow == getDataLength() || options.autoEdit), $(activeCellNode).addClass("active"), $(rowsCache[activeRow].rowNode).addClass("active"), options.editable && t && isCellPotentiallyEditable(activeRow, activeCell) && (clearTimeout(h_editorLoader), options.asyncEditorLoading ? h_editorLoader = setTimeout(function () { makeActiveCellEditable() }, options.asyncEditorLoadDelay) : makeActiveCellEditable())) : activeRow = activeCell = null, o && trigger(self.onActiveCellChanged, getActiveCell()) } function clearTextSelection() { if (document.selection && document.selection.empty) try { document.selection.empty() } catch (e) { } else if (window.getSelection) { var t = window.getSelection(); t && t.removeAllRanges && t.removeAllRanges() } } function isCellPotentiallyEditable(e, t) { var o = getDataLength(); return o > e && !getDataItem(e) ? !1 : columns[t].cannotTriggerInsert && e >= o ? !1 : getEditor(e, t) ? !0 : !1 } function makeActiveCellNormal() { if (currentEditor) { if (trigger(self.onBeforeCellEditorDestroy, { editor: currentEditor }), currentEditor.destroy(), currentEditor = null, activeCellNode) { var e = getDataItem(activeRow); if ($(activeCellNode).removeClass("editable invalid"), e) { var t = columns[activeCell], o = getFormatter(activeRow, t); activeCellNode.innerHTML = o(activeRow, activeCell, getDataItemValueForColumn(e, t), t, e), invalidatePostProcessingResults(activeRow) } } navigator.userAgent.toLowerCase().match(/msie/) && clearTextSelection(), getEditorLock().deactivate(editController) } } function makeActiveCellEditable(e) { if (activeCellNode) { if (!options.editable) throw "Grid : makeActiveCellEditable : should never get called when options.editable is false"; if (clearTimeout(h_editorLoader), isCellPotentiallyEditable(activeRow, activeCell)) { var t = columns[activeCell], o = getDataItem(activeRow); if (trigger(self.onBeforeEditCell, { row: activeRow, cell: activeCell, item: o, column: t }) === !1) return void setFocus(); getEditorLock().activate(editController), $(activeCellNode).addClass("editable"), e || (activeCellNode.innerHTML = ""), currentEditor = new (e || getEditor(activeRow, activeCell))({ grid: self, gridPosition: absBox($container[0]), position: absBox(activeCellNode), container: activeCellNode, column: t, item: o || {}, commitChanges: commitEditAndSetFocus, cancelChanges: cancelEditAndSetFocus }), o && currentEditor.loadValue(o), serializedEditorValue = currentEditor.serializeValue(), currentEditor.position && handleActiveCellPositionChange() } } } function commitEditAndSetFocus() { getEditorLock().commitCurrentEdit() && (setFocus(), options.autoEdit && navigateDown()) } function cancelEditAndSetFocus() { getEditorLock().cancelCurrentEdit() && setFocus() } function absBox(e) { var t = { top: e.offsetTop, left: e.offsetLeft, bottom: 0, right: 0, width: $(e).outerWidth(), height: $(e).outerHeight(), visible: !0 }; t.bottom = t.top + t.height, t.right = t.left + t.width; for (var o = e.offsetParent; (e = e.parentNode) != document.body;) t.visible && e.scrollHeight != e.offsetHeight && "visible" != $(e).css("overflowY") && (t.visible = t.bottom > e.scrollTop && t.top < e.scrollTop + e.clientHeight), t.visible && e.scrollWidth != e.offsetWidth && "visible" != $(e).css("overflowX") && (t.visible = t.right > e.scrollLeft && t.left < e.scrollLeft + e.clientWidth), t.left -= e.scrollLeft, t.top -= e.scrollTop, e === o && (t.left += e.offsetLeft, t.top += e.offsetTop, o = e.offsetParent), t.bottom = t.top + t.height, t.right = t.left + t.width; return t } function getActiveCellPosition() { return absBox(activeCellNode) } function getGridPosition() { return absBox($container[0]) } function handleActiveCellPositionChange() { if (activeCellNode && (trigger(self.onActiveCellPositionChanged, {}), currentEditor)) { var e = getActiveCellPosition(); currentEditor.show && currentEditor.hide && (e.visible ? currentEditor.show() : currentEditor.hide()), currentEditor.position && currentEditor.position(e) } } function getCellEditor() { return currentEditor } function getActiveCell() { return activeCellNode ? { row: activeRow, cell: activeCell } : null } function getActiveCellNode() { return activeCellNode } function scrollRowIntoView(e, t) { var o = e * options.rowHeight, n = (e + 1) * options.rowHeight - viewportH + (viewportHasHScroll ? scrollbarDimensions.height : 0); (e + 1) * options.rowHeight > scrollTop + viewportH + offset ? (scrollTo(t ? o : n), render()) : e * options.rowHeight < scrollTop + offset && (scrollTo(t ? n : o), render()) } function scrollRowToTop(e) { scrollTo(e * options.rowHeight), render() } function scrollPage(e) { var t = e * numVisibleRows; if (scrollTo((getRowFromPosition(scrollTop) + t) * options.rowHeight), render(), options.enableCellNavigation && null != activeRow) { var o = activeRow + t, n = getDataLengthIncludingAddNew(); o >= n && (o = n - 1), 0 > o && (o = 0); for (var l = 0, i = null, r = activePosX; activePosX >= l;) canCellBeActive(o, l) && (i = l), l += getColspan(o, l); null !== i ? (setActiveCellInternal(getCellNode(o, i)), activePosX = r) : resetActiveCell() } } function navigatePageDown() { scrollPage(1) } function navigatePageUp() { scrollPage(-1) } function getColspan(e, t) { var o = data.getItemMetadata && data.getItemMetadata(e); if (!o || !o.columns) return 1; var n = o.columns[columns[t].id] || o.columns[t], l = n && n.colspan; return l = "*" === l ? columns.length - t : l || 1 } function findFirstFocusableCell(e) { for (var t = 0; t < columns.length;) { if (canCellBeActive(e, t)) return t; t += getColspan(e, t) } return null } function findLastFocusableCell(e) { for (var t = 0, o = null; t < columns.length;) canCellBeActive(e, t) && (o = t), t += getColspan(e, t); return o } function gotoRight(e, t, o) { if (t >= columns.length) return null; do t += getColspan(e, t); while (t < columns.length && !canCellBeActive(e, t)); return t < columns.length ? { row: e, cell: t, posX: t } : null } function gotoLeft(e, t, o) { if (0 >= t) return null; var n = findFirstFocusableCell(e); if (null === n || n >= t) return null; for (var l, i = { row: e, cell: n, posX: n }; ;) { if (l = gotoRight(i.row, i.cell, i.posX), !l) return null; if (l.cell >= t) return i; i = l } } function gotoDown(e, t, o) { for (var n, l = getDataLengthIncludingAddNew() ; ;) { if (++e >= l) return null; for (n = t = 0; o >= t;) n = t, t += getColspan(e, t); if (canCellBeActive(e, n)) return { row: e, cell: n, posX: o } } } function gotoUp(e, t, o) { for (var n; ;) { if (--e < 0) return null; for (n = t = 0; o >= t;) n = t, t += getColspan(e, t); if (canCellBeActive(e, n)) return { row: e, cell: n, posX: o } } } function gotoNext(e, t, o) { if (null == e && null == t && (e = t = o = 0, canCellBeActive(e, t))) return { row: e, cell: t, posX: t }; var n = gotoRight(e, t, o); if (n) return n; for (var l = null, i = getDataLengthIncludingAddNew() ; ++e < i;) if (l = findFirstFocusableCell(e), null !== l) return { row: e, cell: l, posX: l }; return null } function gotoPrev(e, t, o) { if (null == e && null == t && (e = getDataLengthIncludingAddNew() - 1, t = o = columns.length - 1, canCellBeActive(e, t))) return { row: e, cell: t, posX: t }; for (var n, l; !n && !(n = gotoLeft(e, t, o)) ;) { if (--e < 0) return null; t = 0, l = findLastFocusableCell(e), null !== l && (n = { row: e, cell: l, posX: l }) } return n } function navigateRight() { return navigate("right") } function navigateLeft() { return navigate("left") } function navigateDown() { return navigate("down") } function navigateUp() { return navigate("up") } function navigateNext() { return navigate("next") } function navigatePrev() { return navigate("prev") } function navigate(e) { if (!options.enableCellNavigation) return !1; if (!activeCellNode && "prev" != e && "next" != e) return !1; if (!getEditorLock().commitCurrentEdit()) return !0; setFocus(); var t = { up: -1, down: 1, left: -1, right: 1, prev: -1, next: 1 }; tabbingDirection = t[e]; var o = { up: gotoUp, down: gotoDown, left: gotoLeft, right: gotoRight, prev: gotoPrev, next: gotoNext }, n = o[e], l = n(activeRow, activeCell, activePosX); if (l) { var i = l.row == getDataLength(); return scrollCellIntoView(l.row, l.cell, !i), setActiveCellInternal(getCellNode(l.row, l.cell)), activePosX = l.posX, !0 } return setActiveCellInternal(getCellNode(activeRow, activeCell)), !1 } function getCellNode(e, t) { return rowsCache[e] ? (ensureCellNodesInRowsCache(e), rowsCache[e].cellNodesByColumnIdx[t]) : null } function setActiveCell(e, t) { initialized && (e > getDataLength() || 0 > e || t >= columns.length || 0 > t || options.enableCellNavigation && (scrollCellIntoView(e, t, !1), setActiveCellInternal(getCellNode(e, t), !1))) } function canCellBeActive(e, t) { if (!options.enableCellNavigation || e >= getDataLengthIncludingAddNew() || 0 > e || t >= columns.length || 0 > t) return !1; var o = data.getItemMetadata && data.getItemMetadata(e); if (o && "boolean" == typeof o.focusable) return o.focusable; var n = o && o.columns; return n && n[columns[t].id] && "boolean" == typeof n[columns[t].id].focusable ? n[columns[t].id].focusable : n && n[t] && "boolean" == typeof n[t].focusable ? n[t].focusable : columns[t].focusable } function canCellBeSelected(e, t) { if (e >= getDataLength() || 0 > e || t >= columns.length || 0 > t) return !1; var o = data.getItemMetadata && data.getItemMetadata(e); if (o && "boolean" == typeof o.selectable) return o.selectable; var n = o && o.columns && (o.columns[columns[t].id] || o.columns[t]); return n && "boolean" == typeof n.selectable ? n.selectable : columns[t].selectable } function gotoCell(e, t, o) { if (initialized && canCellBeActive(e, t) && getEditorLock().commitCurrentEdit()) { scrollCellIntoView(e, t, !1); var n = getCellNode(e, t); setActiveCellInternal(n, o || e === getDataLength() || options.autoEdit), currentEditor || setFocus() } } function commitCurrentEdit() { var e = getDataItem(activeRow), t = columns[activeCell]; if (currentEditor) { if (currentEditor.isValueChanged()) { var o = currentEditor.validate(); if (o.valid) { if (activeRow < getDataLength()) { var n = { row: activeRow, cell: activeCell, editor: currentEditor, serializedValue: currentEditor.serializeValue(), prevSerializedValue: serializedEditorValue, execute: function () { this.editor.applyValue(e, this.serializedValue), updateRow(this.row), trigger(self.onCellChange, { row: activeRow, cell: activeCell, item: e }) }, undo: function () { this.editor.applyValue(e, this.prevSerializedValue), updateRow(this.row), trigger(self.onCellChange, { row: activeRow, cell: activeCell, item: e }) } }; options.editCommandHandler ? (makeActiveCellNormal(), options.editCommandHandler(e, t, n)) : (n.execute(), makeActiveCellNormal()) } else { var l = {}; currentEditor.applyValue(l, currentEditor.serializeValue()), makeActiveCellNormal(), trigger(self.onAddNewRow, { item: l, column: t }) } return !getEditorLock().isActive() } return $(activeCellNode).removeClass("invalid"), $(activeCellNode).width(), $(activeCellNode).addClass("invalid"), trigger(self.onValidationError, { editor: currentEditor, cellNode: activeCellNode, validationResults: o, row: activeRow, cell: activeCell, column: t }), currentEditor.focus(), !1 } makeActiveCellNormal() } return !0 } function cancelCurrentEdit() { return makeActiveCellNormal(), !0 } function rowsToRanges(e) { for (var t = [], o = columns.length - 1, n = 0; n < e.length; n++) t.push(new Slick.Range(e[n], 0, e[n], o)); return t } function getSelectedRows() { if (!selectionModel) throw "Selection model is not set"; return selectedRows } function setSelectedRows(e) { if (!selectionModel) throw "Selection model is not set"; selectionModel.setSelectedRanges(rowsToRanges(e)) } var defaults = { explicitInitialization: !1, rowHeight: 25, defaultColumnWidth: 80, enableAddRow: !1, leaveSpaceForNewRows: !1, editable: !1, autoEdit: !0, enableCellNavigation: !0, enableColumnReorder: !0, asyncEditorLoading: !1, asyncEditorLoadDelay: 100, forceFitColumns: !1, enableAsyncPostRender: !1, asyncPostRenderDelay: 50, autoHeight: !1, editorLock: Slick.GlobalEditorLock, showHeaderRow: !1, headerRowHeight: 25, showTopPanel: !1, topPanelHeight: 25, formatterFactory: null, editorFactory: null, cellFlashingCssClass: "flashing", selectedCellCssClass: "selected", multiSelect: !0, enableTextSelectionOnCells: !1, dataItemColumnValueExtractor: null, fullWidthRows: !1, multiColumnSort: !1, defaultFormatter: defaultFormatter, forceSyncScrolling: !1, addNewRowCssClass: "new-row" }, columnDefaults = { name: "", resizable: !0, sortable: !1, minWidth: 30, rerenderOnResize: !1, headerCssClass: null, defaultSortAsc: !0, focusable: !0, selectable: !0 }, th, h, ph, n, cj, page = 0, offset = 0, vScrollDir = 1, initialized = !1, $container, uid = "slickgrid_" + Math.round(1e6 * Math.random()), self = this, $focusSink, $focusSink2, $headerScroller, $headers, $headerRow, $headerRowScroller, $headerRowSpacer, $topPanelScroller, $topPanel, $viewport, $canvas, $style, $boundAncestors, stylesheet, columnCssRulesL, columnCssRulesR, viewportH, viewportW, canvasWidth, viewportHasHScroll, viewportHasVScroll, headerColumnWidthDiff = 0, headerColumnHeightDiff = 0, cellWidthDiff = 0, cellHeightDiff = 0, absoluteColumnMinWidth, tabbingDirection = 1, activePosX, activeRow, activeCell, activeCellNode = null, currentEditor = null, serializedEditorValue, editController, rowsCache = {}, renderedRows = 0, numVisibleRows, prevScrollTop = 0, scrollTop = 0, lastRenderedScrollTop = 0, lastRenderedScrollLeft = 0, prevScrollLeft = 0, scrollLeft = 0, selectionModel, selectedRows = [], plugins = [], cellCssClasses = {}, columnsById = {}, sortColumns = [], columnPosLeft = [], columnPosRight = [], h_editorLoader = null, h_render = null, h_postrender = null, postProcessedRows = {}, postProcessToRow = null, postProcessFromRow = null, counter_rows_rendered = 0, counter_rows_removed = 0, rowNodeFromLastMouseWheelEvent, zombieRowNodeFromLastMouseWheelEvent; this.debug = function () { var e = ""; e += "\ncounter_rows_rendered:  " + counter_rows_rendered, e += "\ncounter_rows_removed:  " + counter_rows_removed, e += "\nrenderedRows:  " + renderedRows, e += "\nnumVisibleRows:  " + numVisibleRows, e += "\nmaxSupportedCssHeight:  " + maxSupportedCssHeight, e += "\nn(umber of pages):  " + n, e += "\n(current) page:  " + page, e += "\npage height (ph):  " + ph, e += "\nvScrollDir:  " + vScrollDir, alert(e) }, this.eval = function (expr) { return eval(expr) }, $.extend(this, { slickGridVersion: "2.1", onScroll: new Slick.Event, onSort: new Slick.Event, onHeaderMouseEnter: new Slick.Event, onHeaderMouseLeave: new Slick.Event, onHeaderContextMenu: new Slick.Event, onHeaderClick: new Slick.Event, onHeaderCellRendered: new Slick.Event, onBeforeHeaderCellDestroy: new Slick.Event, onHeaderRowCellRendered: new Slick.Event, onBeforeHeaderRowCellDestroy: new Slick.Event, onMouseEnter: new Slick.Event, onMouseLeave: new Slick.Event, onClick: new Slick.Event, onDblClick: new Slick.Event, onContextMenu: new Slick.Event, onKeyDown: new Slick.Event, onAddNewRow: new Slick.Event, onValidationError: new Slick.Event, onViewportChanged: new Slick.Event, onColumnsReordered: new Slick.Event, onColumnsResized: new Slick.Event, onCellChange: new Slick.Event, onBeforeEditCell: new Slick.Event, onBeforeCellEditorDestroy: new Slick.Event, onBeforeDestroy: new Slick.Event, onActiveCellChanged: new Slick.Event, onActiveCellPositionChanged: new Slick.Event, onDragInit: new Slick.Event, onDragStart: new Slick.Event, onDrag: new Slick.Event, onDragEnd: new Slick.Event, onSelectedRowsChanged: new Slick.Event, onCellCssStylesChanged: new Slick.Event, registerPlugin: registerPlugin, unregisterPlugin: unregisterPlugin, getColumns: getColumns, setColumns: setColumns, getColumnIndex: getColumnIndex, updateColumnHeader: updateColumnHeader, setSortColumn: setSortColumn, setSortColumns: setSortColumns, getSortColumns: getSortColumns, autosizeColumns: autosizeColumns, getOptions: getOptions, setOptions: setOptions, getData: getData, getDataLength: getDataLength, getDataItem: getDataItem, setData: setData, getSelectionModel: getSelectionModel, setSelectionModel: setSelectionModel, getSelectedRows: getSelectedRows, setSelectedRows: setSelectedRows, getContainerNode: getContainerNode, render: render, invalidate: invalidate, invalidateRow: invalidateRow, invalidateRows: invalidateRows, invalidateAllRows: invalidateAllRows, updateCell: updateCell, updateRow: updateRow, getViewport: getVisibleRange, getRenderedRange: getRenderedRange, resizeCanvas: resizeCanvas, updateRowCount: updateRowCount, scrollRowIntoView: scrollRowIntoView, scrollRowToTop: scrollRowToTop, scrollCellIntoView: scrollCellIntoView, getCanvasNode: getCanvasNode, focus: setFocus, getCellFromPoint: getCellFromPoint, getCellFromEvent: getCellFromEvent, getActiveCell: getActiveCell, setActiveCell: setActiveCell, getActiveCellNode: getActiveCellNode, getActiveCellPosition: getActiveCellPosition, resetActiveCell: resetActiveCell, editActiveCell: makeActiveCellEditable, getCellEditor: getCellEditor, getCellNode: getCellNode, getCellNodeBox: getCellNodeBox, canCellBeSelected: canCellBeSelected, canCellBeActive: canCellBeActive, navigatePrev: navigatePrev, navigateNext: navigateNext, navigateUp: navigateUp, navigateDown: navigateDown, navigateLeft: navigateLeft, navigateRight: navigateRight, navigatePageUp: navigatePageUp, navigatePageDown: navigatePageDown, gotoCell: gotoCell, getTopPanel: getTopPanel, setTopPanelVisibility: setTopPanelVisibility, setHeaderRowVisibility: setHeaderRowVisibility, getHeaderRow: getHeaderRow, getHeaderRowColumn: getHeaderRowColumn, getGridPosition: getGridPosition, flashCell: flashCell, addCellCssStyles: addCellCssStyles, setCellCssStyles: setCellCssStyles, removeCellCssStyles: removeCellCssStyles, getCellCssStyles: getCellCssStyles, init: finishInitialization, destroy: destroy, getEditorLock: getEditorLock, getEditController: getEditController }), init()
    } $.extend(!0, window, { Slick: { Grid: SlickGrid } }); var scrollbarDimensions, maxSupportedCssHeight
}(jQuery), function (e) {
    function t(t) {
        function o() { Ce = !0 } function n() { Ce = !1, q() } function l(e) { Re = e } function i(e) { ee = e } function r(e) { e = e || 0; for (var t, o = e, n = he.length; n > o; o++) { if (t = he[o][ue], void 0 === t) throw "Each data element must implement a unique 'id' property"; fe[t] = o } } function a() { for (var e, t = 0, o = he.length; o > t; t++) if (e = he[t][ue], void 0 === e || fe[e] !== t) throw "Each data element must implement a unique 'id' property" } function s() { return he } function c(e, t) { void 0 !== t && (ue = t), he = be = e, fe = {}, r(), a(), q() } function d(e) { void 0 != e.pageSize && (ke = e.pageSize, Pe = ke ? Math.min(Pe, Math.max(0, Math.ceil(Ne / ke) - 1)) : 0), void 0 != e.pageNum && (Pe = Math.min(e.pageNum, Math.max(0, Math.ceil(Ne / ke) - 1))), He.notify(u(), null, ce), q() } function u() { var e = ke ? Math.max(1, Math.ceil(Ne / ke)) : 1; return { pageSize: ke, pageNum: Pe, totalRows: Ne, totalPages: e } } function h(e, t) { we = t, Z = e, J = null, t === !1 && he.reverse(), he.sort(e), t === !1 && he.reverse(), fe = {}, r(), q() } function g(e, t) { we = t, J = e, Z = null; var o = Object.prototype.toString; Object.prototype.toString = "function" == typeof e ? e : function () { return this[e] }, t === !1 && he.reverse(), he.sort(), Object.prototype.toString = o, t === !1 && he.reverse(), fe = {}, r(), q() } function f() { Z ? h(Z, we) : J && g(J, we) } function v(e) { me = e, t.inlineFilters && (te = V(), oe = K()), q() } function m(e, o, n) { t.groupItemMetadataProvider || (t.groupItemMetadataProvider = new Slick.Data.GroupItemMetadataProvider), ne = e, le = "function" == typeof ne, ie = o, re = n, Ee = {}, $e = [], q() } function p(e, t) { ae = e, xe = void 0 !== t ? t : xe, se = []; for (var o = ae.length; o--;) se[o] = B(ae[o]); q() } function C(e) { return he[e] } function w(e) { return fe[e] } function R() { if (!ve) { ve = {}; for (var e = 0, t = ge.length; t > e; e++) ve[ge[e][ue]] = e } } function S(e) { return R(), ve[e] } function b(e) { return he[fe[e]] } function y(e) { var t = []; R(); for (var o = 0; o < e.length; o++) { var n = ve[e[o]]; null != n && (t[t.length] = n) } return t } function $(e) { for (var t = [], o = 0; o < e.length; o++) e[o] < ge.length && (t[t.length] = ge[e[o]][ue]); return t } function E(e, t) { if (void 0 === fe[e] || e !== t[ue]) throw "Invalid or non-matching id"; he[fe[e]] = t, pe || (pe = {}), pe[e] = !0, q() } function x(e, t) { he.splice(e, 0, t), r(e), q() } function k(e) { he.push(e), r(he.length - 1), q() } function P(e) { var t = fe[e]; if (void 0 === t) throw "Invalid id"; delete fe[e], he.splice(t, 1), r(t), q() } function N() { return ge.length } function M(e) { return ge[e] } function D(e) { var o = ge[e]; return void 0 === o ? null : o.__group ? t.groupItemMetadataProvider.getGroupRowMetadata(o) : o.__groupTotals ? t.groupItemMetadataProvider.getTotalsRowMetadata(o) : null } function H(e) { Ee[e] = !0, q() } function I(e) { delete Ee[e], q() } function A() { return $e } function L(e) { for (var t, o, n, l = [], i = [], r = 0, a = e.length; a > r; r++) n = e[r], o = le ? ne(n) : n[ne], o = o || 0, t = i[o], t || (t = new Slick.Group, t.count = 0, t.value = o, t.rows = [], l[l.length] = t, i[o] = t), t.rows[t.count++] = n; return l } function _(e) { if (!e.collapsed || xe) { for (var t, o = new Slick.GroupTotals, n = ae.length; n--;) t = ae[n], t.init(), se[n].call(t, e.rows), t.storeResult(o); o.group = e, e.totals = o } } function W(e) { for (var t = e.length; t--;) _(e[t]) } function T(e) { for (var t, o = e.length; o--;) t = e[o], t.collapsed = t.value in Ee, t.title = ie ? ie(t) : t.value } function F(e) { for (var t, o = [], n = 0, l = 0, i = e.length; i > l; l++) { if (t = e[l], o[n++] = t, !t.collapsed) for (var r = 0, a = t.rows.length; a > r; r++) o[n++] = t.rows[r]; !t.totals || t.collapsed && !xe || (o[n++] = t.totals) } return o } function z(e) { var t = /^function[^(]*\(([^)]*)\)\s*{([\s\S]*)}$/, o = e.toString().match(t); return { params: o[1].split(","), body: o[2] } } function B(e) { var t = z(e.accumulate), o = new Function("_items", "for (var " + t.params[0] + ", _i=0, _il=_items.length; _i<_il; _i++) {" + t.params[0] + " = _items[_i]; " + t.body + "}"); return o.displayName = o.name = "compiledAccumulatorLoop", o } function V() { var e = z(me), t = e.body.replace(/return false[;}]/gi, "{ continue _coreloop; }").replace(/return true[;}]/gi, "{ _retval[_idx++] = $item$; continue _coreloop; }").replace(/return ([^;}]+?);/gi, "{ if ($1) { _retval[_idx++] = $item$; }; continue _coreloop; }"), o = ["var _retval = [], _idx = 0; ", "var $item$, $args$ = _args; ", "_coreloop: ", "for (var _i = 0, _il = _items.length; _i < _il; _i++) { ", "$item$ = _items[_i]; ", "$filter$; ", "} ", "return _retval; "].join(""); o = o.replace(/\$filter\$/gi, t), o = o.replace(/\$item\$/gi, e.params[0]), o = o.replace(/\$args\$/gi, e.params[1]); var n = new Function("_items,_args", o); return n.displayName = n.name = "compiledFilter", n } function K() { var e = z(me), t = e.body.replace(/return false[;}]/gi, "{ continue _coreloop; }").replace(/return true[;}]/gi, "{ _cache[_i] = true;_retval[_idx++] = $item$; continue _coreloop; }").replace(/return ([^;}]+?);/gi, "{ if ((_cache[_i] = $1)) { _retval[_idx++] = $item$; }; continue _coreloop; }"), o = ["var _retval = [], _idx = 0; ", "var $item$, $args$ = _args; ", "_coreloop: ", "for (var _i = 0, _il = _items.length; _i < _il; _i++) { ", "$item$ = _items[_i]; ", "if (_cache[_i]) { ", "_retval[_idx++] = $item$; ", "continue _coreloop; ", "} ", "$filter$; ", "} ", "return _retval; "].join(""); o = o.replace(/\$filter\$/gi, t), o = o.replace(/\$item\$/gi, e.params[0]), o = o.replace(/\$args\$/gi, e.params[1]); var n = new Function("_items,_args,_cache", o); return n.displayName = n.name = "compiledFilterWithCaching", n } function G(e, t) { for (var o = [], n = 0, l = 0, i = e.length; i > l; l++) me(e[l], t) && (o[n++] = e[l]); return o } function O(e, t, o) { for (var n, l = [], i = 0, r = 0, a = e.length; a > r; r++) n = e[r], o[r] ? l[i++] = n : me(n, t) && (l[i++] = n, o[r] = !0); return l } function j(e) { if (me) { var o = t.inlineFilters ? te : G, n = t.inlineFilters ? oe : O; Re.isFilterNarrowing ? be = o(be, ee) : Re.isFilterExpanding ? be = n(e, ee, ye) : Re.isFilterUnchanged || (be = o(e, ee)) } else be = ke ? e : e.concat(); var l; return ke ? (be.length < Pe * ke && (Pe = Math.floor(be.length / ke)), l = be.slice(ke * Pe, ke * Pe + ke)) : l = be, { totalRows: be.length, rows: l } } function U(e, t) { var o, n, l, i = [], r = 0, a = t.length; Re && Re.ignoreDiffsBefore && (r = Math.max(0, Math.min(t.length, Re.ignoreDiffsBefore))), Re && Re.ignoreDiffsAfter && (a = Math.min(t.length, Math.max(0, Re.ignoreDiffsAfter))); for (var s = r, c = e.length; a > s; s++) s >= c ? i[i.length] = s : (o = t[s], n = e[s], (ne && (l = o.__nonDataRow || n.__nonDataRow) && o.__group !== n.__group || o.__updated || o.__group && !o.equals(n) || ae && l && (o.__groupTotals || n.__groupTotals) || o[ue] != n[ue] || pe && pe[o[ue]]) && (i[i.length] = s)); return i } function X(e) { ve = null, (Re.isFilterNarrowing != Se.isFilterNarrowing || Re.isFilterExpanding != Se.isFilterExpanding) && (ye = []); var t = j(e); Ne = t.totalRows; var o = t.rows; $e = [], null != ne && ($e = L(o), $e.length && (T($e), ae && W($e), $e.sort(re), o = F($e))); var n = U(ge, o); return ge = o, n } function q() { if (!Ce) { var e = ge.length, t = Ne, o = X(he, me); ke && Pe * ke > Ne && (Pe = Math.max(0, Math.ceil(Ne / ke) - 1), o = X(he, me)), pe = null, Se = Re, Re = {}, t != Ne && He.notify(u(), null, ce), e != ge.length && Me.notify({ previous: e, current: ge.length }, null, ce), o.length > 0 && De.notify({ rows: o }, null, ce) } } function Q(e, t) { var o, n = this, l = n.mapRowsToIds(e.getSelectedRows()); e.onSelectedRowsChanged.subscribe(function (t, i) { o || (l = n.mapRowsToIds(e.getSelectedRows())) }), this.onRowsChanged.subscribe(function (i, r) { if (l.length > 0) { o = !0; var a = n.mapIdsToRows(l); t || (l = n.mapRowsToIds(a)), e.setSelectedRows(a), o = !1 } }) } function Y(e, t) { function o(e) { n = {}; for (var t in e) { var o = ge[t][ue]; n[o] = e[t] } } var n, l; o(e.getCellCssStyles(t)), e.onCellCssStylesChanged.subscribe(function (e, n) { l || t == n.key && n.hash && o(n.hash) }), this.onRowsChanged.subscribe(function (o, i) { if (n) { l = !0, R(); var r = {}; for (var a in n) { var s = ve[a]; void 0 != s && (r[s] = n[a]) } e.setCellCssStyles(t, r), l = !1 } }) } var J, Z, ee, te, oe, ne, le, ie, re, ae, se, ce = this, de = { groupItemMetadataProvider: null, inlineFilters: !1 }, ue = "id", he = [], ge = [], fe = {}, ve = null, me = null, pe = null, Ce = !1, we = !0, Re = {}, Se = {}, be = [], ye = [], $e = [], Ee = {}, xe = !1, ke = 0, Pe = 0, Ne = 0, Me = new Slick.Event, De = new Slick.Event, He = new Slick.Event; return t = e.extend(!0, {}, de, t), {
            beginUpdate: o, endUpdate: n, setPagingOptions: d, getPagingInfo: u, getItems: s, setItems: c, setFilter: v, sort: h, fastSort: g, reSort: f, groupBy: m, setAggregators: p, collapseGroup: H, expandGroup: I, getGroups: A, getIdxById: w, getRowById: S, getItemById: b, getItemByIdx: C, mapRowsToIds: $, mapIdsToRows: y, setRefreshHints: l, setFilterArgs: i, refresh: q, updateItem: E, insertItem: x, addItem: k, deleteItem: P, syncGridSelection: Q, syncGridCellCssStyles: Y, getLength: N, getItem: M, getItemMetadata: D,
            onRowCountChanged: Me, onRowsChanged: De, onPagingInfoChanged: He
        }
    } function o(e) { this.field_ = e, this.init = function () { this.count_ = 0, this.nonNullCount_ = 0, this.sum_ = 0 }, this.accumulate = function (e) { var t = e[this.field_]; this.count_++, null != t && "" != t && NaN != t && (this.nonNullCount_++, this.sum_ += parseFloat(t)) }, this.storeResult = function (e) { e.avg || (e.avg = {}), 0 != this.nonNullCount_ && (e.avg[this.field_] = this.sum_ / this.nonNullCount_) } } function n(e) { this.field_ = e, this.init = function () { this.min_ = null }, this.accumulate = function (e) { var t = e[this.field_]; null != t && "" != t && NaN != t && (null == this.min_ || t < this.min_) && (this.min_ = t) }, this.storeResult = function (e) { e.min || (e.min = {}), e.min[this.field_] = this.min_ } } function l(e) { this.field_ = e, this.init = function () { this.max_ = null }, this.accumulate = function (e) { var t = e[this.field_]; null != t && "" != t && NaN != t && (null == this.max_ || t > this.max_) && (this.max_ = t) }, this.storeResult = function (e) { e.max || (e.max = {}), e.max[this.field_] = this.max_ } } function i(e) { this.field_ = e, this.init = function () { this.sum_ = null }, this.accumulate = function (e) { var t = e[this.field_]; null != t && "" != t && NaN != t && (this.sum_ += parseFloat(t)) }, this.storeResult = function (e) { e.sum || (e.sum = {}), e.sum[this.field_] = this.sum_ } } e.extend(!0, window, { Slick: { Data: { DataView: t, Aggregators: { Avg: o, Min: n, Max: l, Sum: i } } } })
}(jQuery), function (e) { function t(t) { function o(o) { p = e.extend(!0, {}, S, t), v = o, R.subscribe(v.onActiveCellChanged, l(h)), R.subscribe(v.onKeyDown, l(g)), R.subscribe(v.onClick, l(f)) } function n() { R.unsubscribeAll() } function l(e) { return function () { m || (m = !0, e.apply(this, arguments), m = !1) } } function i(e) { for (var t = [], o = 0; o < e.length; o++) for (var n = e[o].fromRow; n <= e[o].toRow; n++) t.push(n); return t } function r(e) { for (var t = [], o = v.getColumns().length - 1, n = 0; n < e.length; n++) t.push(new Slick.Range(e[n], 0, e[n], o)); return t } function a(e, t) { var o, n = []; for (o = e; t >= o; o++) n.push(o); for (o = t; e > o; o++) n.push(o); return n } function s() { return i(C) } function c(e) { d(r(e)) } function d(e) { C = e, w.onSelectedRangesChanged.notify(C) } function u() { return C } function h(e, t) { p.selectActiveRow && d([new Slick.Range(t.row, 0, t.row, v.getColumns().length - 1)]) } function g(e) { var t = v.getActiveCell(); if (t && e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey && (38 == e.which || 40 == e.which)) { var o = s(); o.sort(function (e, t) { return e - t }), o.length || (o = [t.row]); var n, l = o[0], i = o[o.length - 1]; n = 40 == e.which ? t.row < i || l == i ? ++i : ++l : t.row < i ? --i : --l, n >= 0 && n < v.getDataLength() && (v.scrollRowIntoView(n), C = r(a(l, i)), d(C)), e.preventDefault(), e.stopPropagation() } } function f(t) { var o = v.getCellFromEvent(t); if (!o || !v.canCellBeActive(o.row, o.cell)) return !1; var n = i(C), l = e.inArray(o.row, n); if (!(t.ctrlKey || t.shiftKey || t.metaKey)) return !1; if (v.getOptions().multiSelect) if (-1 === l && (t.ctrlKey || t.metaKey)) n.push(o.row), v.setActiveCell(o.row, o.cell); else if (-1 !== l && (t.ctrlKey || t.metaKey)) n = e.grep(n, function (e, t) { return e !== o.row }), v.setActiveCell(o.row, o.cell); else if (n.length && t.shiftKey) { var a = n.pop(), s = Math.min(o.row, a), c = Math.max(o.row, a); n = []; for (var u = s; c >= u; u++) u !== a && n.push(u); n.push(a), v.setActiveCell(o.row, o.cell) } return C = r(n), d(C), t.stopImmediatePropagation(), !0 } var v, m, p, C = [], w = this, R = new Slick.EventHandler, S = { selectActiveRow: !0 }; e.extend(this, { getSelectedRows: s, setSelectedRows: c, getSelectedRanges: u, setSelectedRanges: d, init: o, destroy: n, onSelectedRangesChanged: new Slick.Event }) } e.extend(!0, window, { Slick: { RowSelectionModel: t } }) }(jQuery);